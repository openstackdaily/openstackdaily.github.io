<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mastering Distributed Rate Limiting: Scaling to 1M Requests Per Second | Tech Interview Blog</title>
  <meta name="description" content="Learn how to build distributed rate limiters that handle 1M requests/second across 100 data centers with sub-10ms latency using hybrid architectures and gossip protocols.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true,theme:'dark',themeVariables:{primaryColor:'var(--accent)',primaryTextColor:'var(--text)',primaryBorderColor:'var(--border)',lineColor:'var(--accent)',secondaryColor:'var(--bg-secondary)',tertiaryColor:'var(--bg-card)'}});</script>
  <link rel="stylesheet" href="/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöÄ</text></svg>">
</head>
<body>
<header><div class="container header-content">
    <a href="/" class="logo">üöÄ DevInsights</a>
    <nav>
      <a href="/">Home</a>
      <a href="/categories/">Topics</a>
      <a href="https://reel-interview.github.io" target="_blank">Practice ‚Üí</a>
    </nav>
  </div></header>
<main><article class="article"><div class="container">
  <a href="/categories/system-design/" style="color:var(--text-secondary);text-decoration:none;font-size:0.875rem">‚Üê System Design</a>
  <div class="article-header">
    <h1>Mastering Distributed Rate Limiting: Scaling to 1M Requests Per Second</h1>
    <div class="article-meta"><span class="tag">System Design</span><span class="difficulty advanced">advanced</span><span class="tag">dist-sys</span> <span class="tag">architecture</span></div>
  </div>
  <p class="article-intro">In today's hyper-connected world, distributed systems must handle massive traffic loads while maintaining fairness and preventing abuse. Designing a rate limiter that can process 1 million requests per second across 100 data centers with sub-10ms latency is one of the most challenging problems in system architecture. Let's explore how to build such a system without sacrificing performance or accuracy.</p>
  <div class="article-content">
    <h2>The Core Challenge: Accuracy vs Performance</h2>When building distributed rate limiters at scale, you face a fundamental trade-off. Strict accuracy requires coordination between nodes, which introduces latency. High performance demands local decisions, which may lead to temporary overages. The sweet spot lies in a hybrid approach that combines fast local processing with eventual consistency guarantees.</p><p>The key insight is that perfect accuracy isn't always necessary. A 1-2% temporary overage is often acceptable in exchange for order-of-magnitude performance improvements. This allows us to design systems that can handle enterprise-scale traffic while maintaining reasonable fairness guarantees.<h2>Architecture Overview: The Hybrid Approach</h2>Our solution combines three key components working in harmony:</p><p>1. <strong>Local Rate Limiters</strong>: Each node maintains its own counters using efficient algorithms<br>2. <strong>Gossip Protocol</strong>: Nodes periodically exchange information to achieve cluster-wide consistency<br>3. <strong>Hybrid Decision Making</strong>: Fast local decisions with periodic synchronization</p><p>This architecture allows us to make decisions in under 1ms for most requests while keeping the system accurate within acceptable tolerances. The gossip protocol ensures that no single node becomes a bottleneck, and the system can gracefully handle node failures and network partitions.<h2>Local Token Buckets: The First Line of Defense</h2>Each node in our distributed system maintains a local token bucket implementation. Here's how it works:<br><ul><li>Each node receives a quota allocation (total_limit / num_nodes)</li><br><li>Tokens refill at a configured rate based on the global limit</li><br><li>Local decisions happen in microseconds (<1ms)</li><br><li>The system may briefly allow bursts above the global limit</li><br></ul><br>The token bucket algorithm is particularly well-suited for this use case because it handles burst traffic gracefully while maintaining long-term rate compliance. When a request arrives, we check if tokens are available locally. If so, we allow the request immediately and deduct a token. This path is extremely fast and handles the vast majority of requests.<h2>Sliding Window Counters: Precision Timing</h2>For more granular control, we implement sliding window counters alongside our token buckets. These track requests in time-based buckets (typically 1-second intervals) and provide more accurate rate limiting for specific time windows.</p><p>The sliding window approach can use either Redis sorted sets for distributed scenarios or in-memory data structures for local-only decisions. The key innovation is weighted counting for window boundaries, which smooths the transition between time buckets and prevents artificial spikes at bucket boundaries.</p><p>This combination of token buckets (for burst handling) and sliding windows (for precision) gives us the best of both worlds: fast response times with accurate rate limiting.<h2>Gossip Synchronization: Achieving Eventual Consistency</h2>The magic happens in our gossip protocol implementation. Nodes exchange counter deltas every 100-500ms using an epidemic broadcast pattern. This ensures that information about cluster-wide usage propagates quickly without creating a central bottleneck.</p><p>Here's the synchronization flow:</p><p>1. Nodes track their local usage deltas between sync cycles<br>2. Every 200ms (configurable), nodes exchange deltas with random peers<br>3. Each node adjusts its local quota based on cluster-wide usage<br>4. The epidemic spread ensures all nodes eventually converge</p><p>This approach means that during normal operation, most nodes will have a reasonably accurate view of global usage. If one node is experiencing higher traffic, it will automatically receive a smaller quota allocation in the next sync cycle.<h2>Handling Edge Cases and Failure Modes</h2>Real-world systems must handle edge cases gracefully. Here's how we address common failure scenarios:</p><p><strong>Hot Partitions</strong>: When certain keys or users generate disproportionate traffic, we use consistent hashing with virtual nodes to distribute the load evenly across the cluster.</p><p><strong>Network Partitions</strong>: During network splits, we implement conservative limits (fail-safe mode). Nodes assume they're the only active partition and reduce their quotas accordingly to prevent global overages.</p><p><strong>Burst Traffic</strong>: We pre-allocate burst capacity (typically 120% of steady-state limit) to handle legitimate traffic spikes without blocking valid users.</p><p><strong>Node Failures</strong>: When nodes leave or join the cluster, quotas are automatically redistributed among remaining nodes to maintain the global rate limit.<h2>Implementation Details: The Algorithm in Action</h2>Here's our complete hybrid rate limiting algorithm:</p><p><pre><code class="language-">Algorithm: Hybrid Rate Limiter<br>1. Check local token bucket for available tokens<br>2. If tokens available, allow request immediately (<1ms)<br>3. If near local limit, check gossip state for cluster usage<br>4. Background: sync counter deltas every 200ms via gossip<br>5. Adjust local quota based on cluster-wide load patterns<br>6. Handle edge cases (partitions, hot keys, bursts)<br></code></pre></p><p>The beauty of this approach is its simplicity. Most requests follow the fast path (steps 1-2), while the background synchronization (steps 4-5) ensures long-term accuracy. The system self-heals and adapts to changing traffic patterns without manual intervention.<h2>Scalability Considerations: Beyond the Basics</h2>Building a rate limiter that handles 1M RPS requires careful attention to scalability:</p><p><strong>Horizontal Scaling</strong>: Nodes can be added dynamically, with quotas automatically redistributed. The gossip protocol naturally incorporates new nodes without requiring reconfiguration.</p><p><strong>Geographic Distribution</strong>: For global applications, implement regional rate limiters with cross-region aggregation. Each region handles its local traffic while periodically syncing with other regions to maintain global limits.</p><p><strong>Storage Optimization</strong>: Use in-memory stores like Redis or Memcached with TTL-based cleanup for counter data. This ensures that storage doesn't become a bottleneck as the system scales.</p><p><strong>Monitoring and Alerting</strong>: Implement comprehensive monitoring to track overage rates, sync latency, and node health. Set up alerts for when the system deviates from expected accuracy thresholds.<h2>Performance Trade-offs: Choosing the Right Approach</h2>Different applications require different balances between accuracy and performance:</p><p><strong>Strict Accuracy</strong>: Use centralized Redis with Lua scripts for atomic operations. This provides perfect accuracy but introduces higher latency (~50ms) and creates a potential bottleneck.</p><p><strong>High Performance</strong>: Local-only decisions with minimal coordination. This delivers the best performance (<1ms) but may exceed limits by 5-10% during normal operation.</p><p><strong>Balanced Approach</strong>: Our gossip-based hybrid solution with 1-2% overage tolerance. This provides sub-10ms latency while maintaining reasonable accuracy for most use cases.</p><p>The choice depends on your specific requirements. Financial applications might prefer strict accuracy, while social media platforms often opt for maximum performance with looser accuracy requirements.<h2>üìä Visual Overview</h2><div class="mermaid">graph TD
    A[Client Request] --> B[Load Balancer]
    B --> C[Node 1: Local Rate Limiter]
    B --> D[Node 2: Local Rate Limiter]
    B --> E[Node 3: Local Rate Limiter]
    
    C --> F[Local Token Bucket]
    D --> G[Local Token Bucket]
    E --> H[Local Token Bucket]
    
    F -.Gossip Sync.-> G
    G -.Gossip Sync.-> H
    H -.Gossip Sync.-> F
    
    C --> I[Redis Cache]
    D --> I
    E --> I
    
    I --> J[Sliding Window Counters]
    
    F --> K{Tokens Available?}
    K -->|Yes| L[Allow Request]
    K -->|No| M[Reject: 429]
    
    N[Gossip Manager] --> F
    N --> G
    N --> H
    
    O[Quota Adjuster] --> N
    I -.Periodic Sync.-> O</div>
    <h2>üé¨ Wrapping Up</h2>
    <p>Building a distributed rate limiter that can handle 1 million requests per second is challenging but achievable with the right architecture. By combining local token buckets, sliding window counters, and gossip-based synchronization, we can create systems that deliver sub-10ms latency while maintaining reasonable accuracy. The key is understanding your specific requirements and choosing the right balance between performance and consistency. As you implement these patterns, remember that the best systems are those that can gracefully handle failures and adapt to changing traffic patterns without manual intervention.</p>
  </div>
  <div class="cta-box">
    <p>Ready to put this into practice?</p>
    <a href="https://reel-interview.github.io/channel/system-design" class="cta-button">Practice Interview Questions ‚Üí</a>
  </div>
</div></article></main>
<footer><div class="container">
    <p>Built for devs who want to level up üî•</p>
    <p style="margin-top:0.5rem">¬© 2025 DevInsights ‚Ä¢ <a href="https://reel-interview.github.io">Reel Interview</a></p>
  </div></footer></body></html>